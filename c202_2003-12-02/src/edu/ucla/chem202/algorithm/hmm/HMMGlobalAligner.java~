package edu.ucla.chem202.algorithm.hmm;

/*
 * Author: Teresa Breyer, Gary Chen, Sul-min Kim
 * Created: Saturday, November 15, 2003 11:06:55 PM
 * Modified: Saturday, November 15, 2003 11:06:55 PM
 */

import edu.ucla.chem202.*;
import edu.ucla.chem202.io.*;
import edu.ucla.chem202.algorithm.*;
import edu.ucla.chem202.algorithm.hmm.*;
import java.util.List;
import java.lang.Math;
import java.util.*;
import java.lang.reflect.*;

import java.io.*;


/**
* Align two sequences using dynamic programming.
*/
	
public class HMMGlobalAligner
	implements HMMAligner
{
	private HMM myHMM;
	private Sequence curSeq;
	private double probability;
        private double probBaseE; // the var probability, but not converted to log 10
	private int numberResidues;
	private int numberColumns;
	private Cell[][] matrix;
	// the following variables are deprecated. remove asap.
	private	double[][] D; // move to DELETION
	private double[][] M; // move to MATCH
	private TerminalCell begin;
	private TerminalCell end;

	
	/**
	* @author: Teresa Breyer
	*/
	
	
	public void init(HMM hiddenMarkovModel)
	{
		myHMM = hiddenMarkovModel;
	}
	
	/**
	* @author: Teresa Breyer
	*/

	public void computeBackwardProbs()
	throws DataFormatException	{
		StringBuffer sequence = new StringBuffer(curSeq.getRawSeq());

		numberResidues = curSeq.getLength();
		numberColumns = myHMM.getLength();

		matrix[numberColumns - 1][numberResidues].bMatch = Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.END, numberColumns));

		matrix[numberColumns - 1][numberResidues].bDelete = Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.END, numberColumns));

		// last row of M
		for (int j = numberResidues - 1; j >=0 ; j--)
			matrix[numberColumns - 1][j].bMatch = matrix[numberColumns - 1][j+1].bMatch +				
			Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), 
			numberColumns - 1)) + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION,  
			numberColumns - 1));

		// last row of D
		for (int j = numberResidues - 2; j >=0 ; j--)
			matrix[numberColumns - 1][j].bDelete = 0; // -INF	// can't go to INSERTION directly, so not possible

		// last column of D
		for (int i = numberColumns - 2; i >= 0;  i--)
		{
			//Logger.debugln("i=" + i + " " + myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION,i+1));
			matrix[i][numberResidues].bDelete = matrix[i+1][numberResidues].bDelete +
				Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION,i+1));
		}

		// last column of M
		for (int i = numberColumns - 2; i >= 0; i--)
		{	
			//Logger.debugln("i=" + i);
			matrix[i][numberResidues].bMatch = matrix[i+1][numberResidues].bDelete +
				Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION,i+1));
		}

		// need the second last row and columns because of the -INF entries in last row and column

		// second last row of M
		for (int j = numberResidues - 1; j >=0 ; j--)
			matrix[numberColumns - 2][j].bMatch = MathUtil.addLogLog(matrix[numberColumns - 1][j+1].bMatch +
					Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), numberColumns - 1)) +
					Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.MATCH, numberColumns - 1)),
					matrix[numberColumns - 2][j+1].bMatch + Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(j), 
					numberColumns - 2)) + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION, numberColumns - 2)));

		// second last row of D
		for (int j = numberResidues - 1; j >=0 ; j--) {
			//Logger.debugln("j=" + j + " " +  matrix[numberColumns - 1][j+1].bMatch + " " + myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), numberColumns - 1) + " " +myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, numberColumns - 1));
			matrix[numberColumns - 2][j].bDelete = matrix[numberColumns - 1][j+1].bMatch + Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), numberColumns - 1)) +
				Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, numberColumns - 1));
		}

		// general case
		for (int i = numberColumns - 3; i >= 0; i--) {
			for (int j = numberResidues - 1; j >= 0; j--) {

				/*matrix[i][j].bMatch = matrix[i+1][j+1].bMatch * 
				myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1) * 
				myHMM.getTransissionProb(myHMM.MATCH, myHMM.MATCH, i+1) +
					matrix[i][j+1].bMatch * myHMM.getEmissionProb(myHMM.MATCH, 
				sequence.charAt(j), i) * myHMM.getTransitionProb(myHMM.MATCH, 
				myHMM.INSERTION, i) +
					matrix[i+1][j].bDelete * myHMM.getTransitionProb(myHMM.MATCH, 
				myHMM.DELETION, i+1); */
				/*Logger.debugln("Match " + matrix[i+1][j+1].bMatch + " " + myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1) + " " +
						myHMM.getTransitionProb(myHMM.MATCH, myHMM.MATCH, i+1));
				Logger.debugln("Insertion " + matrix[i][j+1].bMatch + " " + myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(j), i) + " " +
					myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION, i));
				Logger.debugln("Deletion " + matrix[i+1][j].bDelete + " " + myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, i+1) + " " );
				*/
				matrix[i][j].bMatch = MathUtil.addLogLog(matrix[i+1][j+1].bMatch + 
					Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1)) +
					Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.MATCH, i+1)),
					matrix[i][j+1].bMatch + Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(j), i)) +
					Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION, i)),
					matrix[i+1][j].bDelete + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, i+1)));

				/*matrix[i][j].bDelete = matrix[i+1][j].bDelete *  
				myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i+1) +
					matrix[i+1][j+1].bMatch * 
				myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1) * 
				myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, i+1);*/
				/*Logger.debugln("Match " + matrix[i+1][j+1].bMatch + " " + myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1) + " "
					+ myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, i+1));
				Logger.debugln("Delete " + matrix[i+1][j].bDelete + " " + myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i+1));
				*/
				matrix[i][j].bDelete = MathUtil.addLogLog(matrix[i+1][j].bDelete + 
					Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i+1)),
					matrix[i+1][j+1].bMatch + Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(j), i+1)) +
					Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, i+1)));

				}
		}
		// first row - first colum - last row
		// first column
		for (int i = 0; i < numberColumns; i++)
			matrix[i][0].pMatch =  0;//-INF
		for (int i = 0; i < numberColumns-1; i++)
			matrix[i][0].pDelete =  matrix[i][0].bDelete + matrix[i][0].fDelete;
		
		// first row
		for (int  j = 1; j < numberResidues + 1 ; j++)
			matrix[0][j].pMatch = matrix[0][j].bMatch + matrix[0][j].fMatch;	
		for (int  j = 1; j < numberResidues + 1 ; j++)
			matrix[0][j].pDelete = 0;//-INF
		
		//last row
		for (int  j = 1; j < numberResidues + 1 ; j++)
			matrix[numberColumns-1][j].pMatch = matrix[numberColumns-1][j].bMatch + matrix[numberColumns-1][j].fMatch;	
		for (int  j = 0; j < numberResidues ; j++)
			matrix[numberColumns-1][j].pDelete = 0;//-INF
		matrix[numberColumns-1][numberResidues].pDelete = matrix[numberColumns-1][numberResidues].bDelete + matrix[numberColumns-1][numberResidues].fDelete;

		// general case
		for (int i = 1; i < numberColumns - 1; i++) {
			for (int j = 1; j < numberResidues + 1; j++) {
				matrix[i][j].pMatch = matrix[i][j].bMatch + matrix[i][j].fMatch;
				matrix[i][j].pDelete = matrix[i][j].bDelete + matrix[i][j].fDelete;
			}
		}
		Logger.debug("LOG_PROB from backward");
		double p2;
		p2 = MathUtil.addLogLog(matrix[0][1].bMatch + Math.log(myHMM.getTransitionProb(myHMM.BEGIN, myHMM.MATCH, 0))+ 
			Math.log(myHMM.getEmissionProb(myHMM.MATCH,sequence.charAt(0), 0)), 
			matrix[0][0].bDelete + 
			Math.log(myHMM.getTransitionProb(myHMM.BEGIN, myHMM.DELETION, 0)))/Math.log(10);
		
		Logger.debugln(" = " + p2);
		begin.totalProb = p2;
	}

	/**
	* @author: Teresa Breyer
	*/

	public void computeForwardProbs()
	throws DataFormatException
	{
		StringBuffer sequence = new StringBuffer(curSeq.getRawSeq());

		numberResidues = curSeq.getLength();
		numberColumns = myHMM.getLength();

		matrix[0][0].fDelete = Math.log(myHMM.getTransitionProb(myHMM.BEGIN, 
			myHMM.DELETION, 0));
		matrix[0][1].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, 
			sequence.charAt(0), 0) ) +
			Math.log(myHMM.getTransitionProb(myHMM.BEGIN, myHMM.MATCH, 0));

		// first row of M
		for (int j = 2; j < numberResidues + 1; j++) {
			matrix[0][j].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, 
				sequence.charAt(j-1), 0)) +
				matrix[0][j-1].fMatch + Math.log( myHMM.getTransitionProb(myHMM.MATCH, 
				myHMM.INSERTION, 0)) ;
		}

		// first column of D
		for (int i = 1; i < numberColumns; i++) {
			matrix[i][0].fDelete = matrix[i-1][0].fDelete + 
			Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i));
		}

		matrix[1][1].fDelete =  matrix[0][1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, 1));
		Logger.debugln("1 1");
		matrix[1][1].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(0), 1)) +
		matrix[0][0].fDelete + Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, 1)) ;

		//second column both
		for (int i = 2; i < numberColumns; i++) {
			matrix[i][1].fDelete = MathUtil.addLogLog(matrix[i-1][1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, i)),
				matrix[i-1][1].fDelete + Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i))); // second column of D
			matrix[i][1].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(0), i)) +
				matrix[i-1][0].fDelete + Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, i)) ;
		}

		// second row both
		for (int j = 2; j < numberResidues + 1; j++) {
			matrix[1][j].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(j-1), 1)) +
				MathUtil.addLogLog(matrix[0][j-1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.MATCH, 1)),
					matrix[1][j-1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION, 1)));
			matrix[1][j].fDelete = matrix[0][j].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, 1));
		}

		// general case
		for (int i = 2; i < numberColumns; i++) {
			for (int j = 2; j < numberResidues + 1; j++) {

				matrix[i][j].fMatch = Math.log(myHMM.getEmissionProb(myHMM.MATCH, sequence.charAt(j-1), i)) +
					MathUtil.addLogLog(matrix[i-1][j-1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.MATCH, i)),
					matrix[i][j-1].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.INSERTION, i)),
					matrix[i-1][j-1].fDelete + Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.MATCH, i))) ;
				matrix[i][j].fDelete = MathUtil.addLogLog(matrix[i-1][j].fMatch + Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.DELETION, i)),
					matrix[i-1][j].fDelete + Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.DELETION, i)));
			}
		}

		/*if (matrix[numberColumns-1][numberResidues].fMatch >= matrix[numberColumns-1][numberResidues].fDelete) {
			Logger.debugln("prob for match greater than delete");
			probBaseE = matrix[numberColumns-1][numberResidues].fMatch + 
			    Math.log(1 + Math.exp(matrix[numberColumns-1][numberResidues].fDelete-
						  matrix[numberColumns-1][numberResidues].fMatch));
			probability = (matrix[numberColumns-1][numberResidues].fMatch +	Math.log(1 + Math.exp(matrix[numberColumns-1][numberResidues].fDelete- 
				matrix[numberColumns-1][numberResidues].fMatch))) / Math.log(10);
		} else {
			Logger.debugln("prob for match less than delete");
			probBaseE = matrix[numberColumns-1][numberResidues].fDelete +
			    Math.log(1 + Math.exp(matrix[numberColumns-1][numberResidues].fMatch-
						  matrix[numberColumns-1][numberResidues].fDelete));
			probability = (matrix[numberColumns-1][numberResidues].fDelete +
				Math.log(1 + Math.exp(matrix[numberColumns-1][numberResidues].fMatch- 
				matrix[numberColumns-1][numberResidues].fDelete))) / Math.log(10);
		}*/
		
		probability = MathUtil.addLogLog(matrix[numberColumns-1][numberResidues].fMatch + 
			Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.END, numberColumns)),
			matrix[numberColumns-1][numberResidues].fDelete + 
			Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.END, numberColumns)))/Math.log(10);
		probBaseE = MathUtil.addLogLog(matrix[numberColumns-1][numberResidues].fMatch + 
			Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.END, numberColumns)),
			matrix[numberColumns-1][numberResidues].fDelete + 
			Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.END, numberColumns)));
		end.totalProb = probability;
		Logger.debug("LOG_PROB from forward");
		Logger.debugln(" = " + probability);
	}
	
	/**
	* @author: Gary Chen
	*/

	private void pad(String toFormat) {
		int cellwidth = 6;
		int strWidth = toFormat.length(); 
		for (int i=0;i<cellwidth-strWidth;i++) {
			Logger.debug(" ");
		}
		Logger.debug(toFormat);
	}
	
	private char hmmState(byte byteValue) {
		char code = '*';
		switch (byteValue) {
		case HMM.DELETION:
			code = 'D';
			break;
		case HMM.INSERTION:
			code = 'I';
			break;
		case HMM.MATCH:
			code = 'M';
			break;
		case HMM.BEGIN:
			code = 'B';
			break;
		case HMM.END:
			code = 'E';
		}
		return code;
	}
	
	private void printDataStructure(String fieldName, Class fieldType) {
		
		try {
			for (int i = 0; i < matrix.length; i++) {
				for (int j = 0; j < matrix[0].length; j++) {
					Class cellClass = matrix[i][j].getClass();
					Field field = cellClass.getDeclaredField(fieldName);
					if (fieldType.toString().equals("double")) {
						pad(""+MathUtil.round(field.getDouble(matrix[i][j])));
					}
					else if (fieldType.toString().equals("int")) {
						pad(""+field.getInt(matrix[i][j]));
					}					
					else if (fieldType.toString().equals("class edu.ucla.chem202.algorithm.hmm.HMMGlobalAligner$Cell")) {
						Cell prevCell = (Cell)field.get(matrix[i][j]);
						if (prevCell!=null)	pad(prevCell.yLoc+","+prevCell.xLoc);
						else pad("null");
					}
					else if (fieldType.toString().equals("byte")) {
						byte byteValue = field.getByte(matrix[i][j]);
						char code = hmmState(byteValue);						
						Logger.debug(code+"");
					}
					Logger.debug(" ");
				}
				Logger.debugln("");
			}
		}
		catch (Exception ex) {
			Logger.debugln("Couldn't output datastructure for "+fieldName+" because "+ex.getMessage());
			ex.printStackTrace();
		}
	}
	
	/**
	* @author: Gary Chen
	*/

	public void printDataStructure()
	{
		Class cellClass = new Cell().getClass();
		
		Field[] fields = cellClass.getDeclaredFields();
		Logger.debugln("Cell has "+fields.length+" fields.");
		for (int count=0;count<fields.length;count++) {			
			Class fieldType = fields[count].getType();
			String fieldName = fields[count].getName();
			Logger.debugln("");
			Logger.debugln("field "+fieldName+" of type "+fieldType.toString()+":");			
			printDataStructure(fields[count].getName(),fields[count].getType());
		}
	}
	
	/**
	* @author: Gary Chen
	* All this does is populate the grid	
	*/
	
	public void align(Sequence seq)
	throws DataFormatException{
		curSeq = seq;
		int hmmLength = myHMM.getLength();
		int seqLength = seq.getLength()+1;
		matrix = new Cell[hmmLength][seqLength];
		for (int y=0;y<hmmLength;y++) {
			for (int x=0;x<seqLength;x++) {
				matrix[y][x] = new Cell();
				matrix[y][x].yLoc = y;
				matrix[y][x].xLoc = x;
			}
		}
		begin = new TerminalCell();
		end = new TerminalCell();
		computeForwardProbs();
		computeBackwardProbs();
		computeViterbiProbs();
	}
	
	/**
	* @author: Gary Chen
	* Compute best path and generate traceback
	* Code is handling boundary conditions first before general conditions for performance reasons.
	*/
	
	public void computeViterbiProbs()
	throws DataFormatException {
		String sequence = curSeq.getRawSeq();
		// *** FIRST ROW AND COLUMN ***
		// initial condition for delete state from begin
		matrix[0][0].vDelete = Math.log(myHMM.getTransitionProb(HMM.BEGIN, HMM.DELETION, 0));
		matrix[0][0].prevStateToDelete = HMM.BEGIN;		
		// first column of D.  DEGENERATE condition where only previous move available which is deletion.
		for (int i = 1; i < numberColumns; i++) {	
			matrix[i][0].vDelete = matrix[i-1][0].vDelete + Math.log(myHMM.getTransitionProb(HMM.DELETION, HMM.DELETION, i));			
			matrix[i][0].deleteTraceBack = matrix[i-1][0]; // only one traceback possible. point up for deletion
			matrix[i][0].prevStateToDelete = HMM.DELETION;	// previous move was a deletion
		}
		// initial condition for match state from begin		
		matrix[0][1].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(0), 0) ) + 
			Math.log(myHMM.getTransitionProb(HMM.BEGIN, HMM.MATCH, 0));
		matrix[0][1].prevStateToMatch = HMM.BEGIN;
		// first row of M. DEGENERATE condition where only previous move available which is insertion.
		for (int j = 2; j < numberResidues + 1; j++) {
			matrix[0][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), 0)) + 
				matrix[0][j-1].vMatch + Math.log( myHMM.getTransitionProb(HMM.MATCH, HMM.INSERTION, 0)) ;
			matrix[0][j].matchTraceBack = matrix[0][j-1];  // only one traceback possible. point left for insertion
			//matrix[0][j].prevStateToMatch = HMM.INSERTION; // previous move was a insertion
			matrix[0][j].prevStateToMatch = HMM.MATCH; // previous move was a insertion
		}
		// *** SECOND ROW AND COLUMN ***
		// DEGENERATE condition for delete state where the ONLY previous state can be a match
		matrix[1][1].vDelete =  matrix[0][1].vMatch + Math.log(myHMM.getTransitionProb(HMM.MATCH, HMM.DELETION, 1));
		matrix[1][1].deleteTraceBack = matrix[0][1];
		matrix[1][1].prevStateToDelete = HMM.MATCH;
		// DEGENERATE condition for match state where the ONLY previous state can be a delete
		matrix[1][1].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(0), 1)) + 
				matrix[0][0].vDelete + Math.log(myHMM.getTransitionProb(HMM.DELETION, HMM.MATCH, 1)) ;
		matrix[1][1].matchTraceBack = matrix[0][1];
		matrix[1][1].prevStateToMatch = HMM.DELETION;
		//second column of match and delete		
		for (int i = 2; i < numberColumns; i++) {
			// normal condition for delete state where the ONLY two previous states are a match and delete
			double m2d = MathUtil.addLog(matrix[i-1][1].vMatch, myHMM.getTransitionProb(HMM.MATCH, HMM.DELETION, i));
			double d2d = MathUtil.addLog(matrix[i-1][1].vDelete, myHMM.getTransitionProb(HMM.DELETION, HMM.DELETION, i));			
			matrix[i][1].deleteTraceBack = matrix[i-1][1];
			if (d2d>=m2d) {
				matrix[i][1].vDelete = d2d;
				matrix[i][1].prevStateToDelete = HMM.DELETION;
			}
			else {
				matrix[i][1].vDelete = m2d; 
				matrix[i][1].prevStateToDelete = HMM.MATCH;
			}			
			// DEGENERATE condition for match state where the ONLY previous state can be a delete
			matrix[i][1].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(0), i)) + 
				matrix[i-1][0].vDelete + Math.log(myHMM.getTransitionProb(HMM.DELETION, HMM.MATCH, i));
			matrix[i][1].matchTraceBack = matrix[i-1][0];
			matrix[i][1].prevStateToMatch = HMM.DELETION;			
		}		
		// second row of match and delete.  
		for (int j = 2; j < numberResidues + 1; j++) {
			// DEGENERATE condition for match state where the ONLY two previous state can be a match or insertion
			double m2m = MathUtil.addLog(matrix[0][j-1].vMatch, myHMM.getTransitionProb(HMM.MATCH, HMM.MATCH, 1));
			double m2i = MathUtil.addLog(matrix[1][j-1].vMatch, myHMM.getTransitionProb(HMM.MATCH, HMM.INSERTION, 1));			
			if (m2m>=m2i) {
				matrix[1][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), 1)) + m2m;				
				matrix[1][j].prevStateToMatch = HMM.MATCH;
				matrix[1][j].matchTraceBack = matrix[0][j-1];
			}
			else {
				matrix[1][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), 1)) + m2i;				
				//matrix[1][j].prevStateToMatch = HMM.INSERTION;
				matrix[1][j].prevStateToMatch = HMM.MATCH;
				matrix[1][j].matchTraceBack = matrix[1][j-1];
			}			
			// DEGENERATE condition for delete state where the ONLY previous state can be a match
			matrix[1][j].vDelete = matrix[0][j].vMatch + Math.log(myHMM.getTransitionProb(HMM.MATCH, HMM.DELETION, 1));
			matrix[1][j].deleteTraceBack = matrix[0][j];
			matrix[1][j].prevStateToDelete = HMM.MATCH;			
		}		
		// *** GENERAL CASE ***
		for (int i = 2; i < numberColumns; i++) {
			for (int j = 2; j < numberResidues + 1; j++) {				
				// normal condition for match state where the ONLY three previous states are a match, insert, and delete
				double m2m = MathUtil.addLog(matrix[i-1][j-1].vMatch, myHMM.getTransitionProb(HMM.MATCH, HMM.MATCH, i));
				double m2i = MathUtil.addLog(matrix[i][j-1].vMatch, myHMM.getTransitionProb(HMM.MATCH, HMM.INSERTION, i));
				double d2m = MathUtil.addLog(matrix[i-1][j-1].vDelete, myHMM.getTransitionProb(HMM.DELETION, HMM.MATCH, i));
				if ((m2i>=d2m) && (m2i>=m2m)) {
					matrix[i][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), i)) + m2i;
					matrix[i][j].matchTraceBack = matrix[i][j-1];
					//matrix[i][j].prevStateToMatch = HMM.INSERTION;
					matrix[i][j].prevStateToMatch = HMM.MATCH;
				}
				else {
					matrix[i][j].matchTraceBack = matrix[i-1][j-1];
					if (m2m>=d2m) {
						matrix[i][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), i)) + m2m;						
						matrix[i][j].prevStateToMatch = HMM.MATCH;
					}
					else {
						matrix[i][j].vMatch = Math.log(myHMM.getEmissionProb(HMM.MATCH, sequence.charAt(j-1), i)) + d2m;						
						matrix[i][j].prevStateToMatch = HMM.DELETION;
					}
				}				
				// normal condition for delete state where the ONLY two previous states are a match and delete
				double m2d = MathUtil.addLog(matrix[i-1][j].vMatch,  myHMM.getTransitionProb(HMM.MATCH, HMM.DELETION, i));
				double d2d = MathUtil.addLog(matrix[i-1][j].vDelete, myHMM.getTransitionProb(HMM.DELETION, HMM.DELETION, i));
				matrix[i][j].deleteTraceBack = matrix[i-1][j];
				if (d2d>=m2d) {
					matrix[i][j].vDelete = d2d;
					matrix[i][j].prevStateToDelete = HMM.DELETION;
				}
				else {
					matrix[i][j].vDelete = m2d;
					matrix[i][j].prevStateToDelete = HMM.MATCH;
				}				
			}
		}
		
		double m2end = matrix[numberColumns-1][numberResidues].fMatch + 
			Math.log(myHMM.getTransitionProb(myHMM.MATCH, myHMM.END, numberColumns));
		double d2end = matrix[numberColumns-1][numberResidues].fDelete+Math.log(myHMM.getTransitionProb(myHMM.DELETION, myHMM.END, numberColumns));
		if (m2end>=d2end) {
			end.prevState = HMM.MATCH;			
		}
		else {
			end.prevState = HMM.DELETION;			
		}
		end.traceBack = matrix[numberColumns-1][numberResidues];			
	}

	/**
	* @author: Teresa Breyer
	*/
	
	
	public double getTotalProb()
	{
		return probability;
	}
	
	/**
	* @author: Sul-min Kim
	*/	
	
	public void printPosteriorProbs() {
	    // start from bottom right cell
	    // get its traceback cell
	    // get the traceback state of the traceback cell to determine whether to emit something or not
	    // print the posterior prob at the cell
	    // repeat until traceback is null	
		
	    
	    String sequence = curSeq.getRawSeq();
		
		int hmmLength = myHMM.getLength();
		int seqLength = curSeq.getLength()+1;		
		
	    int row = hmmLength - 1; //index of last row element;
	    int col = seqLength - 1; //index of last col element -> numberResidues-1;
	    
	    Cell currCell = end.traceBack;	// start at end
		byte currState = end.prevState;
		Cell prevCell = currCell.matchTraceBack;
		Stack output = new Stack(); //hold output for stdout

	    Logger.debugln("*****SMK DEBUG*****");  		
	    Logger.debugln("row,col: "+row+","+col+" seq: "+sequence+ " TotProb Base 10: "+probability+" TotProb Base E: "+probBaseE);	
		
		HMMAlignment hA = (HMMAlignment)((HMMAlignment)myHMM).clone(); //create duplicate RCMSA		
		hA.addSequence(curSeq); // plug in the new sequence in this clone
		
	    while(currCell != null){			
			//Logger.debugln("\tcurrCell tb = "+currCell.matchTraceBack.xLoc+" "+currCell.matchTraceBack.yLoc);
			if(currState == HMM.MATCH){
				if(currCell.yLoc>0){
					prevCell = currCell.matchTraceBack;
				}
				// when the current cell is a MATCH state and has come from a previous cell which was in 
				// the SAME ROW, it is a INSERTION
				if(prevCell.yLoc == currCell.yLoc){
					//Logger.debugln("adding insert gapchar at "+(row));
					hA.addInsertAtCol(row);
					Logger.debugln("while loop: INSERT: row,col = "+currCell.yLoc+","+currCell.xLoc+" pMatch:"+currCell.pMatch);
					output.push(" LETTER:"+sequence.charAt(col-1)+"\tPROB="+ 
						MathUtil.round( Math.exp( currCell.pMatch - probBaseE ) * 100 ) +"%");
				}
				else{
					//Logger.debugln("adding match at "+(row));
					Logger.debugln("while loop: MATCH: row,col = "+currCell.yLoc+","+currCell.xLoc+" pMatch:"+currCell.pMatch);
					output.push(" LETTER:"+sequence.charAt(col-1)+"\tPROB="+ 
						MathUtil.round( Math.exp( currCell.pMatch - probBaseE ) * 100 ) +"%");
				}
				if(matrix[row][col] != null &&
		       		matrix[row][col].prevStateToMatch != HMM.BEGIN && matrix[row][col].prevStateToMatch != HMM.UNDEF){					
						Logger.debugln("\t_____iterator____");
						Logger.debugln("\tcurr row,col: "+currCell.yLoc+","+currCell.xLoc+
				       	" matchTB: "+matrix[row][col].matchTraceBack.yLoc+","+matrix[row][col].matchTraceBack.xLoc+
				       	" stateTB: "+hmmState(matrix[row][col].matchTraceBack.prevStateToMatch));
						Logger.debugln("\t_________________");
						prevCell = currCell;
						currState = currCell.prevStateToMatch;
						currCell = matrix[row][col].matchTraceBack;
						row = currCell.yLoc;
						col = currCell.xLoc;						
		    	}
				else{
					Logger.debugln("breaking while loop in match matrix");
					break;
		    	}
			}
			if(currState == HMM.DELETION){
				//Logger.debugln("adding delete gapchar at "+(col-1));
				hA.addDeleteAtCol(col-1);
				Logger.debugln("while loop: DELETION: row,col = "+currCell.yLoc+","+currCell.xLoc+" pDel: "+currCell.pDelete );
				output.push(" LETTER:"+Alignment.GAP_CHAR+"\tPROB="+ 
				MathUtil.round( Math.exp( currCell.pDelete - probBaseE ) * 100 ) +"%");
				if(matrix[row][col] != null &&
		       		matrix[row][col].prevStateToDelete != HMM.BEGIN &&
		       		matrix[row][col].prevStateToDelete != 0){
					
						Logger.debugln("\t_____iterator____");
						Logger.debugln("\tcurr row,col: "+currCell.yLoc+","+currCell.xLoc+
				       	" deleteTB: "+matrix[row][col].deleteTraceBack.yLoc+","+matrix[row][col].deleteTraceBack.xLoc+
				       	" stateTB: "+hmmState(matrix[row][col].deleteTraceBack.prevStateToDelete));
						Logger.debugln("\t_________________");
						currState = currCell.prevStateToDelete;
						currCell = matrix[row][col].deleteTraceBack;
						row = currCell.yLoc;
						col = currCell.xLoc;						
		    	}
				else{
					Logger.debugln("breaking while loop in delete matrix");
					break;
		    	}
			}
		}
		
		// output posterior probs to stdout
		int colCount = 1;
	    while (!output.empty()){
						
			//for(int k=output.size()-1; k>=0; k--){
				Logger.println("COLUMN:"+(colCount++)+"\t"+output.pop().toString() );				
			//}
	    }
		try{
			hA.clustalOut(Logger.getOut());
			// making sure the original datastructure is not tampered with.
			//((Alignment)myHMM).clustalOut(Logger.getOut());
		} catch (IOException ex){
			Logger.debugln("Couldn't not output the clustal output because: "+ex.getMessage());
		}
	    Logger.debugln("*****SMK DEBUG DONE*****");		
	}	
	
	class Cell {		
		double fMatch;
		double fDelete;
		double bMatch;
		double bDelete;
		double vMatch;
		double vDelete;
		double pMatch;
		double pDelete;
		int xLoc;
		int yLoc;
		Cell matchTraceBack;
		byte prevStateToMatch;
		Cell deleteTraceBack;
		byte prevStateToDelete;
	}
	
	class TerminalCell {
		double totalProb;
		Cell traceBack;
		byte prevState;		
	}
}
